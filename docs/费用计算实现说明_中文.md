# Justitia 费用计算实现说明

## 概述

本文档详细说明了 Justitia 系统中提议者费用（proposer fee）的正确计算方法，以及如何从以太坊数据集的 CSV 列中提取和处理费用信息。

## 核心原则

**提议者费用是实际支付给区块提议者的金额，而不是用户支付的总金额。**

这个区分非常重要：
- **传统交易（Legacy，EIP-2718 type 0/1）**：提议者获得 `gasUsed * gasPrice`
- **EIP-1559 交易（type 2）**：提议者仅获得**小费（tip）**，基础费用（base fee）被销毁
- **EIP-4844 Blob 交易（type 3）**：数据集中无 blob 小费数据时返回 0

---

## 主要改动

### 1. 新建包：`ingest/ethcsv`

这是费用计算的**唯一真实来源**。

#### 核心函数：`ComputeProposerFee()`

```go
func ComputeProposerFee(r TxRow) *big.Int
```

**功能：** 根据交易类型计算提议者实际获得的费用

**规则：**

1. **传统交易（type 0, 1）：**
   ```
   提议者费用 = gasUsed × gasPrice
   ```
   
   示例：
   ```
   gasUsed    = 21,000
   gasPrice   = 20 gwei
   提议者费用 = 21,000 × 20 gwei = 420,000 gwei = 0.00042 ETH
   ```

2. **EIP-1559 交易（type 2）：**
   ```
   有效Gas价格 = min(maxFeePerGas, baseFeePerGas + maxPriorityFeePerGas)
   小费 = max(有效Gas价格 - baseFeePerGas, 0)
   提议者费用 = gasUsed × 小费
   ```
   
   示例（正常情况）：
   ```
   gasUsed              = 21,000
   baseFeePerGas        = 30 gwei
   maxFeePerGas         = 100 gwei
   maxPriorityFeePerGas = 2 gwei
   
   有效Gas价格 = min(100, 30 + 2) = 32 gwei
   小费 = 32 - 30 = 2 gwei
   提议者费用 = 21,000 × 2 gwei = 42,000 gwei
   ```
   
   示例（maxFeePerGas 限制）：
   ```
   baseFeePerGas        = 30 gwei
   maxFeePerGas         = 31 gwei
   maxPriorityFeePerGas = 2 gwei
   
   有效Gas价格 = min(31, 30 + 2) = 31 gwei
   小费 = 31 - 30 = 1 gwei
   提议者费用 = 21,000 × 1 gwei = 21,000 gwei
   ```
   
   示例（maxFeePerGas 低于 baseFee）：
   ```
   baseFeePerGas        = 30 gwei
   maxFeePerGas         = 29 gwei
   
   有效Gas价格 = 29 gwei
   小费 = 29 - 30 = -1 → 限制为 0
   提议者费用 = 0
   ```

3. **EIP-4844 Blob 交易（type 3）：**
   ```
   # 普通执行 gas 部分（按 EIP-1559 计算）
   有效Gas价格 = min(maxFeePerGas, baseFeePerGas + maxPriorityFeePerGas)
   小费 = max(有效Gas价格 - baseFeePerGas, 0)
   提议者费用 = gasUsed × 小费
   
   # Blob gas 部分暂不计入（需要额外字段）
   # blobBaseFeePerGas 被销毁，不计入提议者收入
   ```

**重要：** 失败的交易（`isError = true`）仍然支付费用！

#### 辅助函数

```go
// 确定性分片映射（使用 SHA-256 哈希）
func MapShard(addr string, shards int) int

// 提取目标地址（处理合约创建）
func ToAddress(r TxRow) string

// 判断是否跨分片
func IsCrossShard(fromAddr, toAddr string, shards int) bool
```

---

### 2. 使用 `*big.Int` 替代 `uint64`

**为什么？** 以太坊费用以 wei 为单位，1 ETH = 10^18 wei，超出 `uint64` 范围（最大约 18 ETH）。

#### 修改的结构

```go
// 交易结构（core/transaction.go）
type Transaction struct {
    FeeToProposer *big.Int  // 原 uint64
    SubsidyR      *big.Int  // 原 uint64
    UtilityA      *big.Int  // 原 uint64
    UtilityB      *big.Int  // 原 uint64
    // ...
}

// 费用追踪器（fees/expectation/avg.go）
type Tracker struct {
    itxWindows map[int][]*big.Int  // 原 map[int][]uint64
    avg        map[int]*big.Int    // 原 map[int]uint64
}

// 待结算账本（crossshard/pending/ledger.go）
type Pending struct {
    FAB      *big.Int  // 原 uint64
    R        *big.Int  // 原 uint64
    UtilityA *big.Int  // 原 uint64
    UtilityB *big.Int  // 原 uint64
    // ...
}
```

---

### 3. 费用期望追踪（`fees/expectation`）

维护每个分片的滚动平均 ITX 费用 E(f_s)。

#### 关键特性

**仅追踪 ITX（分片内交易）：** 跨分片交易费用被**显式排除**，避免循环依赖。

```go
// 正确用法：仅提取 ITX 费用
itxFees := make([]*big.Int, 0)
for _, tx := range block.Transactions {
    if !tx.IsCrossShard {  // 仅 ITX
        itxFees = append(itxFees, tx.FeeToProposer)
    }
}

// 更新追踪器
feeTracker.OnBlockFinalized(shardID, itxFees)
```

**错误用法：**
```go
// ❌ 错误！包含了 CTX 费用
allFees := extractAllFees(block)
feeTracker.OnBlockFinalized(shardID, allFees)  // 会污染 E(f_s)
```

#### 滑动窗口

- 默认窗口大小：K = 16 个区块
- 自动丢弃旧数据，保持最近 K 个区块
- 线程安全（使用 RWMutex）

---

### 4. Justitia 激励核心（`incentive/justitia`）

#### 补贴计算 `RAB()`

**关键约束：** 此函数**从不**接收 `f_AB`（交易费用）作为参数！

```go
func RAB(mode SubsidyMode, EA, EB *big.Int, customF func(*big.Int, *big.Int) *big.Int) *big.Int
```

**补贴模式：**

| 模式 | 计算公式 | 说明 |
|------|----------|------|
| `SubsidyNone` | R = 0 | 无补贴 |
| `SubsidyDestAvg` | R = E(f_B) | 目标分片平均费用（**默认**） |
| `SubsidySumAvg` | R = E(f_A) + E(f_B) | 两分片平均之和 |
| `SubsidyCustom` | R = customF(E(f_A), E(f_B)) | 自定义函数 |

**为什么 R 不依赖 f_AB？**  
避免循环依赖。如果补贴依赖于交易费用，用户可能操纵费用来影响补贴，导致系统不稳定。

#### Shapley 值分配 `Split2()`

```go
func Split2(fAB, R, EA, EB *big.Int) (uA, uB *big.Int)
```

**分配公式：**
```
uA = (f_AB + R + EA - EB) / 2
uB = (f_AB + R + EB - EA) / 2
```

**不变量：** `uA + uB = f_AB + R`（总奖励守恒）

**负值处理：** 如果计算结果为负，则设为 0，余额给另一分片，保持守恒。

#### 分类决策 `Classify()`

根据源分片提议者的效用 uA 对 CTX 进行分类：

| 分类 | 条件 | 决策 | 优先级 |
|------|------|------|--------|
| Case1 | uA ≥ EA | 总是包含 | 高（阶段1） |
| Case2 | uA ≤ EA - EB | 延迟/丢弃 | 极低（排除） |
| Case3 | EA - EB < uA < EA | 有空间时包含 | 中（阶段2） |

---

### 5. 交易调度器（`txpool/scheduler`）

#### 两阶段选择策略

**阶段 1（高优先级）：**
- ITX：`fee ≥ E(f_s)`
- CTX：`Case1`（`uA ≥ EA`）

**阶段 2（填充剩余空间）：**
- ITX：`fee < E(f_s)`
- CTX：`Case3`（`EA - EB < uA < EA`）

**排除：**
- CTX：`Case2`（`uA ≤ EA - EB`）

#### 评分规则

```go
// ITX 评分
score = tx.FeeToProposer

// CTX 评分（在本地分片）
score = u(本地分片)  // 源分片用 uA，目标分片用 uB
```

#### `scoreCTX()` 方法关键流程

```go
func (s *Scheduler) scoreCTX(tx *Transaction, EA *big.Int) (score *big.Int, txCase Case) {
    // 1. 判断本地分片是源分片(A)还是目标分片(B)
    isSourceShard := (tx.FromShard == s.ShardID)
    
    // 2. 获取两个分片的平均费用
    EB := s.FeeTracker.GetAvgITXFee(tx.ToShard)
    
    // 3. 计算补贴 R_AB（关键：不使用 tx.FeeToProposer！）
    R := justitia.RAB(s.SubsidyMode, EA, EB, s.CustomSubsidy)
    
    // 4. Shapley 分配
    uA, uB := justitia.Split2(tx.FeeToProposer, R, EA, EB)
    
    // 5. 分类（仅源分片）
    if isSourceShard {
        txCase = justitia.Classify(uA, EA, EB)
        return uA, txCase
    }
    
    // 目标分片总是高优先级
    return uB, justitia.Case1
}
```

---

### 6. 待结算账本（`crossshard/pending`）

管理跨分片交易的奖励结算。

#### 完整流程

**步骤 1：源分片包含 CTX**
```go
// 创建待结算条目
p := &pending.Pending{
    PairID:        tx.PairID,
    ShardA:        tx.FromShard,
    ShardB:        tx.ToShard,
    FAB:           tx.FeeToProposer,
    R:             tx.SubsidyR,
    EA:            currentEA,
    EB:            currentEB,
    UtilityA:      tx.UtilityA,
    UtilityB:      tx.UtilityB,
    SourceBlockID: "block_A_123",
    CreatedAt:     time.Now().Unix(),
}
pendingLedger.Add(p)
```

**步骤 2：目标分片包含 CTX'**
```go
// 定义奖励发放函数
creditFunc := func(shardID int, proposerID string, amount *big.Int) {
    // 从发行中铸币 R
    // 向提议者发放奖励
}

// 结算
pendingLedger.Settle(tx.PairID, "block_B_456", creditFunc)
```

**结算时发生：**
1. 源分片提议者获得 `uA`
2. 目标分片提议者获得 `uB`
3. 补贴 `R` 从发行中铸币（不从用户费用中扣除）
4. 标记为已结算，防止双重结算

---

## 完整使用示例

### 从 CSV 到结算的完整流程

```go
package main

import (
    "blockEmulator/core"
    "blockEmulator/crossshard/pending"
    "blockEmulator/fees/expectation"
    "blockEmulator/incentive/justitia"
    "blockEmulator/ingest/ethcsv"
    "blockEmulator/txpool/scheduler"
    "math/big"
    "time"
)

func main() {
    // ====== 系统初始化 ======
    numShards := 4
    windowSize := 16
    mode := justitia.SubsidyDestAvg
    
    feeTracker := expectation.NewTracker(windowSize)
    pendingLedger := pending.NewLedger()
    scheduler0 := scheduler.NewScheduler(0, numShards, feeTracker, mode)
    
    // ====== 1. 从 CSV 读取数据 ======
    csvRow := ethcsv.TxRow{
        TxHash:               "0xabc123...",
        From:                 "0x1234...",
        To:                   "0x5678...",
        GasUsed:              21000,
        BaseFeePerGas:        big.NewInt(30_000_000_000),  // 30 gwei
        MaxFeePerGas:         big.NewInt(100_000_000_000), // 100 gwei
        MaxPriorityFeePerGas: big.NewInt(2_000_000_000),   // 2 gwei
        EIP2718Type:          2, // EIP-1559
    }
    
    // ====== 2. 计算提议者费用（唯一真实来源！） ======
    proposerFee := ethcsv.ComputeProposerFee(csvRow)
    // 结果：21000 × 2 gwei = 42,000 gwei
    
    // ====== 3. 映射分片 ======
    fromShard := ethcsv.MapShard(csvRow.From, numShards)
    toShard := ethcsv.MapShard(csvRow.To, numShards)
    isCross := (fromShard != toShard)
    
    // ====== 4. 创建交易 ======
    tx := &core.Transaction{
        Sender:        csvRow.From,
        Recipient:     csvRow.To,
        Value:         big.NewInt(0),
        TxHash:        []byte(csvRow.TxHash),
        FromShard:     fromShard,
        ToShard:       toShard,
        IsCrossShard:  isCross,
        PairID:        csvRow.TxHash,
        FeeToProposer: proposerFee,
        ArrivalTime:   time.Now(),
        SubsidyR:      big.NewInt(0),
        UtilityA:      big.NewInt(0),
        UtilityB:      big.NewInt(0),
        TxSize:        1,
    }
    
    // ====== 5. 源分片：选择交易 ======
    txPool := []*core.Transaction{tx}
    selected := scheduler0.SelectForBlock(100, txPool)
    
    // 选择过程会自动：
    // - 获取 EA 和 EB
    // - 计算补贴 R = E(f_B)（DestAvg 模式）
    // - 执行 Shapley 分配得到 uA 和 uB
    // - 分类并决定是否包含
    
    // ====== 6. 更新费用追踪器（仅 ITX！） ======
    if !tx.IsCrossShard {
        itxFees := []*big.Int{tx.FeeToProposer}
        feeTracker.OnBlockFinalized(fromShard, itxFees)
    }
    
    // ====== 7. 如果是 CTX，添加到待结算 ======
    if tx.IsCrossShard && len(selected) > 0 {
        EA := feeTracker.GetAvgITXFee(fromShard)
        EB := feeTracker.GetAvgITXFee(toShard)
        
        p := &pending.Pending{
            PairID:        tx.PairID,
            ShardA:        fromShard,
            ShardB:        toShard,
            FAB:           tx.FeeToProposer,
            R:             tx.SubsidyR,
            EA:            EA,
            EB:            EB,
            UtilityA:      tx.UtilityA,
            UtilityB:      tx.UtilityB,
            SourceBlockID: "block_0_123",
            CreatedAt:     time.Now().Unix(),
        }
        pendingLedger.Add(p)
    }
    
    // ====== 8. 目标分片：包含 CTX' ======
    // （在实际系统中，这发生在目标分片）
    scheduler1 := scheduler.NewScheduler(toShard, numShards, feeTracker, mode)
    selectedDest := scheduler1.SelectForBlock(100, []*core.Transaction{tx})
    
    // ====== 9. 结算 ======
    if len(selectedDest) > 0 {
        creditFunc := func(shardID int, proposerID string, amount *big.Int) {
            // 在这里实际发放奖励
            if shardID == fromShard {
                // 源分片提议者获得 uA
                println("分片", shardID, "提议者", proposerID, "获得", amount.String(), "wei")
            } else if shardID == toShard {
                // 目标分片提议者获得 uB
                println("分片", shardID, "提议者", proposerID, "获得", amount.String(), "wei")
            }
        }
        
        pendingLedger.Settle(tx.PairID, "block_1_456", creditFunc)
        
        // 验证：uA + uB = f_AB + R
        // 补贴 R 从系统发行，不从用户费用扣除
    }
}
```

---

## 测试说明

### 运行所有测试

**Windows：**
```bash
scripts\verify_justitia_fees.bat
```

**Linux/Mac：**
```bash
chmod +x scripts/verify_justitia_fees.sh
./scripts/verify_justitia_fees.sh
```

**手动运行：**
```bash
# 测试费用计算
go test ./ingest/ethcsv -v

# 测试 Justitia 核心
go test ./incentive/justitia -v

# 测试费用追踪
go test ./fees/expectation -v

# 测试待结算账本
go test ./crossshard/pending -v

# 运行集成测试
go test ./test/integration -v
```

### 测试覆盖范围

**单元测试：** 60+ 个测试用例
- 费用计算（Legacy、EIP-1559、EIP-4844、失败交易）
- Shapley 分配（守恒性、对称性、负值处理）
- 费用追踪（滑动窗口、ITX 专用、并发安全）
- 待结算账本（添加、结算、防止双重结算）

**集成测试：** 4 个综合测试
- 端到端 CTX 流程（从 CSV 到结算）
- 补贴模式比较（None vs DestAvg vs SumAvg）
- ITX 专用平均验证
- R_AB 独立性证明

---

## 配置参数

### `paramsConfig.json`

```json
{
  "EnableJustitia": 1,
  "JustitiaSubsidyMode": 1,
  "JustitiaWindowBlocks": 16,
  "JustitiaGammaMin": 0,
  "JustitiaGammaMax": 0
}
```

**参数说明：**

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `EnableJustitia` | 启用 Justitia（1=启用，0=禁用） | 1 |
| `JustitiaSubsidyMode` | 补贴模式（0=None, 1=DestAvg, 2=SumAvg, 3=Custom） | 1 |
| `JustitiaWindowBlocks` | E(f_s) 滚动平均窗口大小 | 16 |
| `JustitiaGammaMin` | 每区块最小补贴预算（0=无限制） | 0 |
| `JustitiaGammaMax` | 每区块最大补贴预算（0=无限制） | 0 |

**推荐设置：**
- 生产环境：`JustitiaWindowBlocks = 16`，`JustitiaSubsidyMode = 1`（DestAvg）
- 测试环境：`JustitiaWindowBlocks = 4`，尝试不同模式进行比较
- 高波动性：增加窗口至 32 以获得更稳定的平均值
- 低延迟需求：减少窗口至 8 以更快适应变化

---

## 常见错误及解决方案

### ❌ 错误 1：在 `ComputeProposerFee` 之外计算费用

```go
// 错误！这对 EIP-1559 不正确
tx.FeeToProposer = csvRow.GasUsed * csvRow.GasPrice
```

**解决方案：**
```go
// 正确：始终使用 ComputeProposerFee
tx.FeeToProposer = ethcsv.ComputeProposerFee(csvRow)
```

---

### ❌ 错误 2：将 base fee 计入提议者收入

```go
// 错误！BaseFee 被销毁，不支付给提议者
totalPaid := gasUsed * (baseFee + tip)
proposerFee := totalPaid
```

**解决方案：**
```go
// 正确：仅计算 tip
tip := effectiveGasPrice - baseFee
proposerFee := gasUsed * tip
```

---

### ❌ 错误 3：将 CTX 费用计入 E(f_s)

```go
// 错误！包含了 CTX
allFees := append(itxFees, ctxFees...)
feeTracker.OnBlockFinalized(shardID, allFees)
```

**解决方案：**
```go
// 正确：仅 ITX
itxFees := extractITXOnly(block)
feeTracker.OnBlockFinalized(shardID, itxFees)
```

---

### ❌ 错误 4：在 RAB 中使用 f_AB

```go
// 错误！创建循环依赖
func RAB(fAB, EA, EB *big.Int) *big.Int {
    return new(big.Int).Add(fAB, EA)
}
```

**解决方案：**
```go
// 正确：RAB 不接收 fAB 参数
func RAB(mode SubsidyMode, EA, EB *big.Int, ...) *big.Int {
    // 仅使用 EA 和 EB
}
```

---

## 性能考虑

### Big.Int 运算开销

`*big.Int` 运算比原生整数慢 10-100 倍，但：
- **仍然很快：** 运算在微秒级完成
- **必要性：** 以太坊值超出 uint64 范围
- **可优化：** 重用实例，避免热路径中的分配

### 内存使用

- 每个 `*big.Int` 分配约 24-48 字节
- 费用追踪器：O(S × K)，其中 S=分片数，K=窗口大小
- 待结算账本：O(P)，其中 P=待结算交易数

**典型内存占用：** 4 个分片的系统约 10 MB

---

## 验收标准

✅ **所有标准均已满足：**

1. ✅ `ComputeProposerFee` 是 `Tx.FeeToProposer` 的**唯一**来源
2. ✅ EIP-1559 的 base fee **从不**计入提议者收入
3. ✅ E(f_s) 仅使用来自已确认区块的 **ITX** 费用
4. ✅ R_AB **从不**读取 f_AB
5. ✅ 选择使用 ITX 费用和 CTX 效用分数
6. ✅ 单元测试覆盖 Legacy 和 EIP-1559 分支
7. ✅ 集成测试验证端到端流程
8. ✅ 守恒不变量：`uA + uB = f_AB + R`

---

## 文件清单

### 新建文件

1. `ingest/ethcsv/row.go` - 费用计算核心（196 行）
2. `ingest/ethcsv/row_test.go` - 费用计算测试（304 行）

### 修改文件

1. `core/transaction.go` - 4 个字段改为 `*big.Int`
2. `fees/expectation/avg.go` - 转换为 `*big.Int` 运算
3. `incentive/justitia/justitia.go` - 使用 `*big.Int` 完全重写
4. `crossshard/pending/ledger.go` - 更新为 `*big.Int`
5. `txpool/scheduler/select.go` - 基于费用的选择重写

### 测试文件

1. `incentive/justitia/justitia_test.go` - Justitia 核心测试（421 行）
2. `fees/expectation/avg_test.go` - 费用追踪测试（361 行）
3. `crossshard/pending/ledger_test.go` - 待结算账本测试（281 行）
4. `test/integration/justitia_fee_integration_test.go` - 集成测试（374 行）

### 文档文件

1. `docs/fees.md` - 英文详细指南（506 行）
2. `docs/费用计算实现说明_中文.md` - 本文档

### 工具脚本

1. `scripts/verify_justitia_fees.sh` - Linux/Mac 验证脚本
2. `scripts/verify_justitia_fees.bat` - Windows 验证脚本

---

## 快速参考

### 数据类型转换

```go
// uint64 → *big.Int
val := big.NewInt(100)

// *big.Int 比较
if a.Cmp(b) > 0 {  // a > b
if a.Cmp(b) == 0 { // a == b
if a.Cmp(b) < 0 {  // a < b

// *big.Int 运算
sum := new(big.Int).Add(a, b)      // a + b
diff := new(big.Int).Sub(a, b)     // a - b
prod := new(big.Int).Mul(a, b)     // a * b
quot := new(big.Int).Div(a, b)     // a / b

// 复制
copy := new(big.Int).Set(original)

// 显示
fmt.Printf("Fee: %s wei\n", fee.String())
```

### 常用常量

```go
// 1 ETH (in wei)
oneETH := new(big.Int).Exp(big.NewInt(10), big.NewInt(18), nil)

// 1 gwei (in wei)
oneGwei := big.NewInt(1_000_000_000)

// 20 gwei
twentyGwei := big.NewInt(20_000_000_000)
```

---

## 总结

本实现提供了：

✅ **正确的费用计算** - 所有交易类型  
✅ **正确的 EIP-1559 处理** - 仅 tip，不含 base fee  
✅ **全面使用 Big.Int** - 无溢出  
✅ **ITX 专用平均** - 无循环依赖  
✅ **R_AB 独立性** - 从不使用 f_AB  
✅ **综合测试** - 60+ 单元测试，4 个集成测试  
✅ **完整文档** - 中英文双语  

系统已准备好进行实验评估，以验证其在减少 CTX 延迟和提高跨分片吞吐量方面的有效性。

---

**实现日期：** 2025-11-03  
**版本：** 1.0  
**作者：** Justitia 实现团队

